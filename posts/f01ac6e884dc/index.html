<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Exploring the Internals of Channels in Go" /><meta name="author" content="Kamna Garg" /><meta property="og:locale" content="en" /><meta name="description" content="Introduction" /><meta property="og:description" content="Introduction" /><link rel="canonical" href="/posts/f01ac6e884dc/" /><meta property="og:url" content="/posts/f01ac6e884dc/" /><meta property="og:site_name" content="Kamna" /><meta property="og:image" content="/assets/f01ac6e884dc/1*LfkUCZxCu0CHOjB1CIydzg.png" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-06-29T22:02:24+00:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="/assets/f01ac6e884dc/1*LfkUCZxCu0CHOjB1CIydzg.png" /><meta property="twitter:title" content="Exploring the Internals of Channels in Go" /><meta name="twitter:site" content="@kamna90" /><meta name="twitter:creator" content="@Kamna Garg" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Kamna Garg"},"dateModified":"2023-10-12T16:36:40+00:00","datePublished":"2023-06-29T22:02:24+00:00","description":"Introduction","headline":"Exploring the Internals of Channels in Go","image":"/assets/f01ac6e884dc/1*LfkUCZxCu0CHOjB1CIydzg.png","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/f01ac6e884dc/"},"url":"/posts/f01ac6e884dc/"}</script><title>Exploring the Internals of Channels in Go | Kamna</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Kamna"><meta name="application-name" content="Kamna"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/favicons/1621252237275.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Kamna</a></div><div class="site-subtitle font-italic">Womanwhocode</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="javascript:location.href = 'mailto:' + ['kamna90123','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Exploring the Internals of Channels in Go</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Exploring the Internals of Channels in Go</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1688076144" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jun 29, 2023 </em> </span> <span> Updated <em class="" data-ts="1697128600" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Oct 12, 2023 </em> </span><div class="mt-3 mb-3"> <a href="/assets/f01ac6e884dc/1*LfkUCZxCu0CHOjB1CIydzg.png" class="popup img-link preview-img shimmer"><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1200 630'%3E%3C/svg%3E" data-src="/assets/f01ac6e884dc/1*LfkUCZxCu0CHOjB1CIydzg.png" alt="Preview Image" width="1200" height="630" class="lazyload" data-proofer-ignore></a></div><div class="d-flex justify-content-between"> <span> By <em> <a href=""></a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2395 words"> <em>13 min</em> read</span></div></div></div><div class="post-content"><h3 id="exploring-the-internals-of-channels-in-go"><span class="mr-2"><strong>Exploring the Internals of Channels in Go</strong></span><a href="#exploring-the-internals-of-channels-in-go" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="introduction"><span class="mr-2"><strong>Introduction</strong></span><a href="#introduction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Channels are a vital component of concurrent programming in Go. They provide a safe and efficient way for goroutines to communicate and share information. Instead of directly sharing memory, Go promotes the use of channels for inter-goroutine communication. In this blog, we will delve into the internals of channels and explore how they work behind the scenes. So, let’s dive in and uncover the mysteries of Go channels!</p><blockquote><p>A goroutine is a lightweight thread managed by the Go runtime, enabling concurrent execution of functions or tasks in Go programs.</p></blockquote><h3 id="define-channel"><span class="mr-2">Define Channel</span><a href="#define-channel" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>To define a channel in Go, you can use the syntax: <code class="language-plaintext highlighter-rouge">var channelName chan ElementType</code> . For example, <code class="language-plaintext highlighter-rouge">var intChannel chan int</code> creates an unbuffered channel for transmitting integers. If you want to create a buffered channel, use <code class="language-plaintext highlighter-rouge">make(chan ElementType, bufferSize)</code> it to specify the capacity of the channel.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>ch :<span class="o">=</span> make<span class="o">(</span>chan string, 4<span class="o">)</span> // buffered channel
ch :<span class="o">=</span> make<span class="o">(</span>chan int<span class="o">)</span> // unbuffered channel
</pre></table></code></div></div><p>Channels in Go are designed to be <strong><em>goroutine-safe</em></strong> and follow the <strong><em>FIFO</em></strong> (First-In-First-Out) order. To meet these requirements, channels utilize a <strong><em>circular queue with a lock</em></strong> as their underlying implementation. The circular queue allows for efficient enqueueing and dequeuing of values, maintaining the order in which they were sent. The lock ensures that only one goroutine can access the channel at a time, preventing race conditions and ensuring synchronized access to the queue.</p><p>So when we define a channel using the above syntax, the channel is created from the hchan struct, which has the following fields.</p><p><a href="/assets/f01ac6e884dc/1*LfkUCZxCu0CHOjB1CIydzg.png" class="popup img-link "><img data-src="/assets/f01ac6e884dc/1*LfkUCZxCu0CHOjB1CIydzg.png" alt="The internal representation of buffered channel at runtime" class="lazyload" data-proofer-ignore></a></p><p>The internal representation of buffered channel at runtime</p><div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="k">type</span> <span class="n">hchan</span> <span class="k">struct</span> <span class="p">{</span>
 <span class="n">qcount</span>   <span class="kt">uint</span>           <span class="c">// total data in the queue</span>
 <span class="n">dataqsiz</span> <span class="kt">uint</span>           <span class="c">// size of the circular queue</span>
 <span class="n">buf</span>      <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="c">// points to an array of dataqsiz elements</span>
 <span class="n">elemsize</span> <span class="kt">uint16</span>
 <span class="n">closed</span>   <span class="kt">uint32</span>
 <span class="n">elemtype</span> <span class="o">*</span><span class="n">_type</span> <span class="c">// element type</span>
 <span class="n">sendx</span>    <span class="kt">uint</span>   <span class="c">// send index</span>
 <span class="n">recvx</span>    <span class="kt">uint</span>   <span class="c">// receive index</span>
 <span class="n">recvq</span>    <span class="n">waitq</span>  <span class="c">// list of recv waiters</span>
 <span class="n">sendq</span>    <span class="n">waitq</span>  <span class="c">// list of send waiters</span>

 <span class="c">// lock protects all fields in hchan, as well as several</span>
 <span class="c">// fields in sudogs blocked on this channel.</span>
 <span class="c">//</span>
 <span class="c">// Do not change another G's status while holding this lock</span>
 <span class="c">// (in particular, do not ready a G), as this can deadlock</span>
 <span class="c">// with stack shrinking.</span>
 <span class="n">lock</span> <span class="n">mutex</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">waitq</span> <span class="k">struct</span> <span class="p">{</span>
 <span class="n">first</span> <span class="o">*</span><span class="n">sudog</span>
 <span class="n">last</span>  <span class="o">*</span><span class="n">sudog</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The hchan struct in Go channels holds several important fields that define the behavior and characteristics of the channel. Here’s a breakdown of these fields:</p><ol><li>qcount: It represents the number of items or data currently present in the channel’s queue.<li>dataqsize: This field indicates the size of the circular queue. It is relevant for buffered channels and is the second parameter provided when creating a channel using the make function.<li>elemsize: It denotes the size of a single element within the channel.<li>buf: The buf field refers to the actual circular queue where data is stored in buffered channels.<li>closed: This field indicates whether the channel is closed. It is initially set to 0 upon channel creation and is set to 1 when the channel is closed using the close( ) function.<li>sendx and recvx: These fields track the current index in the buffer or circular queue. sendx increases when data is added to a buffered channel, while recvx increases when data is received from the channel.<li>recvq and sendq: These fields represent the waiting queues for blocked goroutines that are either waiting to read data from or write data to the channel. It contains reference to another structure <strong><em>sudog,</em></strong> which also plays a role in channel operations but will be explored later in the blog.<li>lock: The lock field is a mutex used to lock the channel during read or write operations, preventing multiple goroutines from accessing it simultaneously and avoiding potential deadlocks.</ol><h3 id="memory-allocation-of-channel"><span class="mr-2"><strong>Memory allocation of channel</strong></span><a href="#memory-allocation-of-channel" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>When a channel is created using the <code class="language-plaintext highlighter-rouge">make</code> function in Go, memory is allocated on the heap for the <code class="language-plaintext highlighter-rouge">hchan</code> struct, and the <code class="language-plaintext highlighter-rouge">make</code> function returns a pointer to that memory. As a result, we don’t need to pass a pointer to the channel during function calls since the channel itself is a pointer under the hood.</p><div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">taskOne</span><span class="p">(</span><span class="n">task</span> <span class="k">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span> <span class="c">// goroutine G1</span>
	<span class="n">job</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">task</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"task One received the job"</span><span class="p">,</span> <span class="n">job</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">taskTwo</span><span class="p">(</span><span class="n">task</span> <span class="k">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span> <span class="c">//  goroutine G2</span>
	<span class="n">job</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">task</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"task Two received the job"</span><span class="p">,</span> <span class="n">job</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span> <span class="c">// goroutine G</span>
	<span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span>
	<span class="n">ch</span> <span class="o">&lt;-</span> <span class="s">"job1"</span>
	<span class="n">ch</span> <span class="o">&lt;-</span> <span class="s">"job2"</span>
	<span class="k">go</span> <span class="n">taskOne</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
	<span class="k">go</span> <span class="n">taskTwo</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
	<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span> <span class="c">// stops the main step to finish before other goroutines.</span>

<span class="p">}</span>
</pre></table></code></div></div><p>At executing line 20, where we are adding one job to channel, the hchan would be like :</p><p><a href="/assets/f01ac6e884dc/1*macrzgmNOQUTszJph4_b4w.png" class="popup img-link "><img data-src="/assets/f01ac6e884dc/1*macrzgmNOQUTszJph4_b4w.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>The sendx and recvx fields in the hchan struct point to the next element to be sent or received from the channel. They increment after each operation and are set to 0 when the queue is full or empty, respectively.</p><p><a href="/assets/f01ac6e884dc/1*EixRLg1gsAOqLL7nU4q_Ug.png" class="popup img-link "><img data-src="/assets/f01ac6e884dc/1*EixRLg1gsAOqLL7nU4q_Ug.png" alt="" class="lazyload" data-proofer-ignore></a></p><blockquote><p>For unbuffered channels in Go, the buf field in the hchan struct will be nil. Unbuffered channels do not have a queue or buffer to store values.</p></blockquote><h3 id="send-and-receive-operations-on-buffered-channel"><span class="mr-2"><strong>Send and receive operations on buffered channel</strong></span><a href="#send-and-receive-operations-on-buffered-channel" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>When a goroutine, such as G(main func in above code snippet), wants to write data to a buffered channel, it follows these steps:</p><ol><li>To ensure safe modification of the channel and the underlying hchan struct, G (the goroutine) <strong><em>acquires a lock</em></strong> before writing data. This lock prevents concurrent access and maintains synchronization.<li>After acquiring the lock, G performs an <strong><em>enqueue operation</em></strong> on the circular queue represented by the <code class="language-plaintext highlighter-rouge">buf</code> field. Before enqueuing the data, a memory copy operation is performed to create a copy of the data.<li>Once the enqueue operation is completed, G1 <strong><em>releases the lock,</em></strong> allowing other goroutines to acquire it and perform their respective operations.</ol><p>When a goroutine, like G1(taskOne) or G2(taskTwo), reads data from the channel, it goes through similar steps as G but with some variations:</p><ol><li>G2 <strong><em>acquires the lock</em></strong> to ensure exclusive access to the channel’s hchan struct.<li>It performs a <strong><em>dequeue operation</em></strong> on the circular queue (buf) to retrieve the next available data. At the same time, G2 performs a memory copy operation on the data it receives, creating a copy.<li>Once G2 has copied the data from the buffer, it <strong><em>releases the lock</em></strong> , allowing other goroutines to access the channel.<li>G2 can now process the copied data as needed, independently of other goroutines.</ol><blockquote><p>It’s important to note that the data obtained by G2 is a separate copy, not a shared reference. This means that each goroutine receives its own copy of the data, ensuring data isolation and avoiding issues related to shared memory access.</p></blockquote><h3 id="buffer-overflowunderflow"><span class="mr-2">Buffer Overflow/Underflow</span><a href="#buffer-overflowunderflow" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>When the buffer capacity of a channel is reached and a goroutine, such as G, attempts to write data, the behavior depends on whether there is a receiver ready to receive the data.</p><p>If there is a receiver (e.g., G2) ready to receive the data, G can proceed to send the data without blocking. The data is then received by G2, and both goroutines continue their execution.</p><p>However, if there is no receiver ready to receive the data, G is paused. G will remain in a paused state, waiting for a receiver to become available.</p><blockquote><p>How does this pausing and resuming of goroutine works?</p></blockquote><p>Go runtime schedular does the magic here.</p><p><a href="/assets/f01ac6e884dc/1*tfnWMArtdtc91cRZjJQD2w.png" class="popup img-link "><img data-src="/assets/f01ac6e884dc/1*tfnWMArtdtc91cRZjJQD2w.png" alt="Blocking call on buffered channel" class="lazyload" data-proofer-ignore></a></p><p>Blocking call on buffered channel</p><h3 id="go-runtime-schedular"><span class="mr-2">Go runtime Schedular</span><a href="#go-runtime-schedular" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Before diving into schedular, let’s understand a bit about goroutines. As you might already be aware, goroutines in Go are <strong><em>user-space threads</em></strong> that are managed by the Go runtime scheduler. Unlike operating system threads, the lifecycle of goroutines is managed by the Go runtime rather than the operating system itself. This distinction makes goroutines lightweight compared to OS threads, resulting in lower resource consumption and reduced scheduling overhead.</p><p>The Go runtime scheduler employs an <strong><em>M:N scheduling model</em></strong> , where M represents the number of goroutines and N represents the number of operating system threads. The scheduler multiplexes or maps these M goroutines onto the available N OS threads. This allows the scheduler to efficiently schedule and switch between goroutines, providing concurrent execution and parallelism on top of the underlying operating system threads.</p><p>By utilizing the M:N scheduling model, the Go runtime scheduler achieves a balance between efficient resource utilization and effective concurrency management. Goroutines can be created and executed with low overhead, allowing developers to utilize concurrent programming in a lightweight and efficient manner.</p><p><a href="/assets/f01ac6e884dc/1*OusoBWg7IMfsjotz-LTJ8w.png" class="popup img-link "><img data-src="/assets/f01ac6e884dc/1*OusoBWg7IMfsjotz-LTJ8w.png" alt="Image source : [Google](https://golang.design/go-questions/sched/mn-model/){:target=&quot;_blank&quot;}" class="lazyload" data-proofer-ignore></a></p><p>Image source : <a href="https://golang.design/go-questions/sched/mn-model/" target="_blank">Google</a></p><p>Go schedular has three structures :</p><ol><li>M represents the OS thread, which is managed by the operating system itself.<li>G represents the goroutine, which is a resizable stack.<li>P represents a context for scheduling and is responsible for running the Go code. It contains Queue of runnable goroutines.</ol><p><a href="/assets/f01ac6e884dc/1*bZyyAx7s7xkE7PMrkyfnNg.png" class="popup img-link "><img data-src="/assets/f01ac6e884dc/1*bZyyAx7s7xkE7PMrkyfnNg.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>There must be association between os thread(M) and goroutine(G) for it to be running. The association between an OS thread and a goroutine is dynamic and can change over time.</p><p>Since go runtime schedular is pretty much clear now, it’s time to move back to previous example.</p><ol><li>Goroutine G tries to send data to channel which is already full.</ol><div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">ch</span> <span class="o">&lt;-</span> <span class="s">"Job3"</span> <span class="c">// Goroutine G sending Job3 on a full channel</span>
</pre></table></code></div></div><p>2. It calls runtime schedular ( <strong><em>gopark</em></strong> function)</p><p>3. Schedular changes G to waiting state and remove the association between OS thread (m) and Goroutine (g) .</p><p>4. Schedular pops the goroutine from runQueue(p) and schedule it to run on OS thread (m) . This is context switching. G is blocked but not the OS thread.</p><p><a href="/assets/f01ac6e884dc/1*pikE8dRBs0zJzRu7EHS2Gg.png" class="popup img-link "><img data-src="/assets/f01ac6e884dc/1*pikE8dRBs0zJzRu7EHS2Gg.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>Here sudog comes into the picture.</p><blockquote><p>The <code class="language-plaintext highlighter-rouge">sudog</code> struct mentioned below is responsible for storing information about a waiting goroutine, such as <code class="language-plaintext highlighter-rouge">g</code> in our case. The Go runtime will park or suspend this sending goroutine ( <code class="language-plaintext highlighter-rouge">g</code> ), ensuring that it is temporarily halted until certain conditions are met.</p></blockquote><p><a href="/assets/f01ac6e884dc/1*H79vXsNBQXNOdmGZRQ7CYw.png" class="popup img-link "><img data-src="/assets/f01ac6e884dc/1*H79vXsNBQXNOdmGZRQ7CYw.png" alt="call ch &lt;- “Job3”(blocking send) creates a sudog and add it to waiting sender" class="lazyload" data-proofer-ignore></a></p><p>call ch &lt;- “Job3”(blocking send) creates a sudog and add it to waiting sender</p><div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="k">type</span> <span class="n">sudog</span> <span class="k">struct</span> <span class="p">{</span>
 <span class="c">// The following fields are protected by the hchan.lock of the</span>
 <span class="c">// channel this sudog is blocking on. shrinkstack depends on</span>
 <span class="c">// this for sudogs involved in channel ops.</span>

 <span class="n">g</span> <span class="o">*</span><span class="n">g</span>

 <span class="n">next</span> <span class="o">*</span><span class="n">sudog</span>
 <span class="n">prev</span> <span class="o">*</span><span class="n">sudog</span>
 <span class="n">elem</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="c">// data element (may point to stack)</span>

 <span class="c">// The following fields are never accessed concurrently.</span>
 <span class="c">// For channels, waitlink is only accessed by g.</span>
 <span class="c">// For semaphores, all fields (including the ones above)</span>
 <span class="c">// are only accessed when holding a semaRoot lock.</span>

 <span class="n">acquiretime</span> <span class="kt">int64</span>
 <span class="n">releasetime</span> <span class="kt">int64</span>
 <span class="n">ticket</span>      <span class="kt">uint32</span>

 <span class="c">// isSelect indicates g is participating in a select, so</span>
 <span class="c">// g.selectDone must be CAS'd to win the wake-up race.</span>
 <span class="n">isSelect</span> <span class="kt">bool</span>

 <span class="c">// success indicates whether communication over channel c</span>
 <span class="c">// succeeded. It is true if the goroutine was awoken because a</span>
 <span class="c">// value was delivered over channel c, and false if awoken</span>
 <span class="c">// because c was closed.</span>
 <span class="n">success</span> <span class="kt">bool</span>

 <span class="n">parent</span>   <span class="o">*</span><span class="n">sudog</span> <span class="c">// semaRoot binary tree</span>
 <span class="n">waitlink</span> <span class="o">*</span><span class="n">sudog</span> <span class="c">// g.waiting list or semaRoot</span>
 <span class="n">waittail</span> <span class="o">*</span><span class="n">sudog</span> <span class="c">// semaRoot</span>
 <span class="n">c</span>        <span class="o">*</span><span class="n">hchan</span> <span class="c">// channel</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Now see what happens when goroutine G1 or G2 are scheduled by runtime schedular and they perform receive operation on same channel.</p><ol><li>The G1/G2 dequeues an object (JOB1) from its buffer, effectively receiving task from queue. It assigns JOB1 to the variable job.<li>Additionally, it dequeues the <strong><em>sudog</em></strong> from the <strong><em>sendq</em></strong> (send queue) and enqueues the <code class="language-plaintext highlighter-rouge">sudog.elem</code> (“JOB3”) into the buffer. It is a performance optimisation here. It saves few memory operations.</ol><div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">job</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch</span> <span class="c">// Goroutine G1/G2 receive data from on a buffered channel</span>
</pre></table></code></div></div><p>3. Call <strong><em>goready</em></strong> function to move G(main func) to runQueue and make it runnable.</p><p><a href="/assets/f01ac6e884dc/1*cuPhhWfGFpZFZSLou0n4gA.png" class="popup img-link "><img data-src="/assets/f01ac6e884dc/1*cuPhhWfGFpZFZSLou0n4gA.png" alt="Current state of hchan when G1/G2 receives data from buffered channel which was blocked earlier" class="lazyload" data-proofer-ignore></a></p><p>Current state of hchan when G1/G2 receives data from buffered channel which was blocked earlier</p><blockquote><p>What happens when receive comes first and channel is empty?</p></blockquote><p>Let’s say channel is empty and Goroutine G1 tries to read data</p><div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">job</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch</span> <span class="c">// Goroutine G1 try to read data from on an empty channel</span>
</pre></table></code></div></div><p><a href="/assets/f01ac6e884dc/1*nl9mu8-UJTILHTv34j8Zxw.png" class="popup img-link "><img data-src="/assets/f01ac6e884dc/1*nl9mu8-UJTILHTv34j8Zxw.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>G1 is temporarily suspended and will remain paused until it is awakened by a subsequent send operation on the channel.</p><ol><li>G1 creates a <code class="language-plaintext highlighter-rouge">sudog</code> and puts it in the <code class="language-plaintext highlighter-rouge">receq</code> (receive queue),<li>It calls <code class="language-plaintext highlighter-rouge">gopark(G1)</code> to pause the execution of the goroutine.</ol><p>Now G(main goroutine) gets the schedular and there are two possibilities.</p><ol><li>Enqueue the task in the buffer and call <code class="language-plaintext highlighter-rouge">goready(G1)</code> : In this case, G would put the task in the channel’s buffer and then call <code class="language-plaintext highlighter-rouge">goready(G1)</code> to make G1 runnable again. This approach involves acquiring the lock and performing additional memory operations.<li>Directly copy the task to the <code class="language-plaintext highlighter-rouge">elem</code> field of the <code class="language-plaintext highlighter-rouge">sudog</code> of G1: Instead of enqueuing the task into the channel’s buffer, G directly copies the task to the <code class="language-plaintext highlighter-rouge">elem</code> field of G1’s <code class="language-plaintext highlighter-rouge">sudog</code> . This approach avoids the need to acquire the lock and reduces the number of memory operations required.</ol><p>The Go scheduler opts for the second option as a performance optimization. By directly copying the task, it minimizes the overhead associated with acquiring locks and reduces memory operations, resulting in improved performance and efficiency.</p><h3 id="sendreceive-in-unbuffered-channels"><span class="mr-2"><strong>Send/receive in unbuffered channels</strong></span><a href="#sendreceive-in-unbuffered-channels" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>In unbuffered channels, the send and receive operations work differently depending on the order of execution:</p><ol><li>When a receive operation occurs first, the sender directly writes the value to the receiver’s stack. This means that the value is transferred directly from the sender to the receiver without any intermediate storage or buffering.<li>Conversely, when a send operation occurs first, the receiver receives the value directly from the <code class="language-plaintext highlighter-rouge">sudog</code> (synchronization data structure) of the sender. The value is obtained without the need for buffering or additional intermediate steps.</ol><p>This direct transfer of data between the sender and receiver in unbuffered channels eliminates the need for a separate buffer, ensuring that the send and receive operations are tightly synchronized. The direct transfer mechanism enables efficient and synchronous communication between goroutines, facilitating a strict one-to-one data exchange pattern.</p><p><em><a href="https://medium.com/womenintechnology/exploring-the-internals-of-channels-in-go-f01ac6e884dc" target="_blank">Post</a> converted from Medium by <a href="https://github.com/ZhgChgLi/ZMediumToMarkdown" target="_blank">ZMediumToMarkdown</a>.</em></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/women/'>Women</a>, <a href='/categories/in/'>in</a>, <a href='/categories/technology/'>Technology</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/go/" class="post-tag no-text-decoration" >go</a> <a href="/tags/goroutines/" class="post-tag no-text-decoration" >goroutines</a> <a href="/tags/backend-development/" class="post-tag no-text-decoration" >backend-development</a> <a href="/tags/threading/" class="post-tag no-text-decoration" >threading</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Exploring%20the%20Internals%20of%20Channels%20in%20Go%20-%20Kamna&url=%2Fposts%2Ff01ac6e884dc%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Exploring%20the%20Internals%20of%20Channels%20in%20Go%20-%20Kamna&u=%2Fposts%2Ff01ac6e884dc%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=%2Fposts%2Ff01ac6e884dc%2F" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/ff56d35a891f/">Mastering Asynchronous Programming with Kotlin Coroutines — Part 1</a><li><a href="/posts/ed48312c0e80/">Think, Stick and just go</a><li><a href="/posts/34d9d3a5565b/">Exploring Context in Golang</a><li><a href="/posts/f01ac6e884dc/">Exploring the Internals of Channels in Go</a><li><a href="/posts/40902c487f04/">Demystifying Kubernetes: Part 1</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/golang/">golang</a> <a class="post-tag" href="/tags/backend-development/">backend-development</a> <a class="post-tag" href="/tags/backend/">backend</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/boyer-moore/">boyer-moore</a> <a class="post-tag" href="/tags/concurrency/">concurrency</a> <a class="post-tag" href="/tags/database/">database</a> <a class="post-tag" href="/tags/deadlock/">deadlock</a> <a class="post-tag" href="/tags/defer/">defer</a> <a class="post-tag" href="/tags/design-patterns/">design-patterns</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/fe2d7a895ab3/"><div class="card-body"> <em class="small" data-ts="1684347531" data-df="ll" > May 17, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Exploring Design Patterns in Go</h3><div class="text-muted small"><p> Exploring Design Patterns in Go Design patterns are reusable solutions to common software design problems that help developers build software that is maintainable, extensible, and scalable. In thi...</p></div></div></a></div><div class="card"> <a href="/posts/34d9d3a5565b/"><div class="card-body"> <em class="small" data-ts="1688655916" data-df="ll" > Jul 6, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Exploring Context in Golang</h3><div class="text-muted small"><p> Exploring Context in Golang Concurrency is an important part of Go programming, and managing goroutines effectively is vital for creating strong and scalable applications. The context package in...</p></div></div></a></div><div class="card"> <a href="/posts/ed48312c0e80/"><div class="card-body"> <em class="small" data-ts="1623950053" data-df="ll" > Jun 17, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Think, Stick and just go</h3><div class="text-muted small"><p> Think, Stick and just go I just finished watching the Skater Girl movie and have penned down my thoughts. First of all, it’s really an inspiring movie. It focuses on the story of a poor village g...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/93eb6138f1c0/" class="btn btn-outline-primary" prompt="Older"><p>Protocol Buffers (ProtoBuf) in Go</p></a> <a href="/posts/34d9d3a5565b/" class="btn btn-outline-primary" prompt="Newer"><p>Exploring Context in Golang</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/golang/">golang</a> <a class="post-tag" href="/tags/backend-development/">backend-development</a> <a class="post-tag" href="/tags/backend/">backend</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/boyer-moore/">boyer-moore</a> <a class="post-tag" href="/tags/concurrency/">concurrency</a> <a class="post-tag" href="/tags/database/">database</a> <a class="post-tag" href="/tags/deadlock/">deadlock</a> <a class="post-tag" href="/tags/defer/">defer</a> <a class="post-tag" href="/tags/design-patterns/">design-patterns</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/kamna90">kamna</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">All rights reserved.</span></p></div><div class="footer-right"><p class="mb-0">Using the <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> theme <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a>.</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
